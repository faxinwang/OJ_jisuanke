/*
蒜头君喜欢下棋。最近它迷上了国际象棋。国际象棋的棋盘可以被当做一个 8×8 的矩阵，棋子被放在
格子里面(不是和中国象棋一样放在线上)。

蒜头君特别喜欢国际象棋里面的马，马的移动规则是这样的：横着走两步之后竖着走一步，或者横着走一步之后
竖着走两步。例如，一匹马在 (3,3) 的位置，则它可以到达的地方有 (1,2)，(2,1)，
(1,4)，(4,1)，(5,2)，(2,5)，(5,4)，(4,5) 八个地方。蒜头君想要
把整个棋盘都放上马，并且让这些马不能相互攻击(即任何一匹马不能走一步之后就到达另一匹马的位置)。蒜头君
当然知道在 8×8 的棋盘上怎么放马，但如果棋盘变为 n×m 的，蒜头君就不懂了。他希望你来帮忙他计算一下究竟
能放多少匹马。

输入格式
共一行，两个整数n和m( 1≤n,m≤1000)，代表棋盘一共有 n 行 m 列。

输出格式
输出一个整数，代表棋盘上最多能放的马的数量。

样例输入1
2 4
样例输出1
4

样例输入2
3 4
样例输出2
6

解题思路：
当棋盘只有一行时，棋盘上全放上棋子即可。
当棋盘只有两行时，参考如下放的方法：

OOXXOOXXOO.....
OOXXOOXXOO.....

即放两排空两排。

其它情况下，参考国际象棋棋盘的颜色，马跳一次一定会从白色格子变为黑色，因此把所有马放在同一颜色下即可。

*/

#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
    int n,m;
    cin>>n>>m;
    if(n > m) swap(n,m);
    if(n == 1) cout<<m<<endl;
    else if(n == 2) cout<<( m / 4 * 4 + min(m % 4 ,2) * 2)<<endl;
    else cout<<(m * n + 1) / 2 <<endl;

    return 0;
}